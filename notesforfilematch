import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;

import java.io.FileInputStream;
import java.io.IOException;
import java.sql.*;
import java.util.HashMap;
import java.util.Map;

public class RateComparison {

    // Database connection details
    private static final String DB_URL = "jdbc:sqlserver://localhost:1433;databaseName=YourDatabase";
    private static final String USER = "your_username";
    private static final String PASSWORD = "your_password";

    public static void main(String[] args) {
        String filePath = "path/to/your/revised_file.xlsx";
        Map<String, Double> revisedRates = loadRevisedRates(filePath);
        Map<String, Double> existingRates = loadExistingRatesFromDatabase();
        
        compareRates(revisedRates, existingRates);
    }

    // Step 1: Load revised rates from the Excel file
    private static Map<String, Double> loadRevisedRates(String filePath) {
        Map<String, Double> revisedRates = new HashMap<>();
        try (FileInputStream fis = new FileInputStream(filePath);
             Workbook workbook = new XSSFWorkbook(fis)) {
             
            Sheet sheet = workbook.getSheetAt(0); // Assuming data is in the first sheet
            for (Row row : sheet) {
                if (row.getRowNum() == 0) continue; // Skip header row
                
                Cell procedureCodeCell = row.getCell(0);
                Cell modifierCell = row.getCell(1);
                Cell rateCell = row.getCell(2);
                
                String procedureCode = procedureCodeCell.getStringCellValue();
                String modifier = modifierCell.getStringCellValue();
                String rateValue = rateCell.getStringCellValue().trim();
                
                // Concatenate ProcedureCode and Modifier to form a unique key
                String uniqueKey = procedureCode + modifier;
                
                // Scrub and handling conditions
                if ("NA".equalsIgnoreCase(rateValue) || "$0".equals(rateValue)) {
                    continue; // Ignore this PROC+MOD combination
                }
                
                double rate;
                if ("M".equalsIgnoreCase(rateValue)) {
                    rate = 0.0; // Manual rate set to 0
                } else {
                    rate = Double.parseDouble(rateValue);
                }
                
                revisedRates.put(uniqueKey, rate);
            }
        } catch (IOException | NumberFormatException e) {
            e.printStackTrace();
        }
        return revisedRates;
    }

    // Step 2: Load existing rates from the SQL Server database
private static Map<String, Map<String, Object>> loadExistingRatesFromDatabase() {
    Map<String, Map<String, Object>> existingRates = new HashMap<>();
    try (Connection connection = DriverManager.getConnection(DB_URL, USER, PASSWORD);
         Statement statement = connection.createStatement()) {
         
        String query = "SELECT procedure_code, modifier, rate, eff_date, term_date FROM procedure_code_table";
        ResultSet rs = statement.executeQuery(query);
        
        while (rs.next()) {
            String procedureCode = rs.getString("procedure_code");
            String modifier = rs.getString("modifier");
            double rate = rs.getDouble("rate");
            Date effDate = rs.getDate("eff_date");
            Date termDate = rs.getDate("term_date");
            
            String uniqueKey = procedureCode + modifier + rate;
            
            Map<String, Object> attributes = new HashMap<>();
            attributes.put("EFF_DATE", effDate);
            attributes.put("TERM_DATE", termDate);
            attributes.put("RATE", rate);
            
            existingRates.put(uniqueKey, attributes);
        }
    } catch (SQLException e) {
        e.printStackTrace();
    }
    return existingRates;
}

    // Step 3: Compare rates between revised source and existing database records
    private static void compareRates(Map<String, Double> revisedRates, Map<String, Double> existingRates) {
	List<String[]> outputResults = new ArrayList<>();
	
for (Map.Entry<String, Double> entry : revisedRates.entrySet()) {
    String uniqueKey = entry.getKey();
    double rate = entry.getValue();
    String assumedEffDate = "2024-01-01";
    String assumedTermDate = "2024-03-31";
    
    String result = "New Code"; // Default result if no conditions match
    
    if (existingRates.containsKey(uniqueKey)) {
        Map<String, Object> dbRecord = existingRates.get(uniqueKey);
        
        Date dbEffDate = (Date) dbRecord.get("EFF_DATE");
        Date dbTermDate = (Date) dbRecord.get("TERM_DATE");
        double dbRate = (double) dbRecord.get("RATE");
        
        if (dbEffDate.toString().equals(assumedEffDate) && dbTermDate.toString().equals(assumedTermDate) && dbRate == rate) {
            result = "No change";
        } else if (dbTermDate.toString().equals(assumedTermDate) && dbRate == rate) {
            result = "No change - Eff date differ";
        } else if (dbTermDate.toString().equals("9999-12-31") && dbRate == rate) {
            result = "No change - Open End date";
        } else if (existingRates.containsKey(procedureCode + modifier)) {
            result = "Rate change";
        }
    }
    
    // Add the result to outputResults for writing to Excel
    outputResults.add(new String[]{uniqueKey, String.valueOf(rate), result});
}

String outputPath = "path/to/output/comparison_results.xlsx";
writeResultsToExcel(outputResults, outputPath);
    }
	
	Cell rateCell = row.getCell(2); // Assuming the rate is in the third column
String rateValue;

if (rateCell.getCellType() == CellType.STRING) {
    rateValue = rateCell.getStringCellValue().trim();
} else if (rateCell.getCellType() == CellType.NUMERIC) {
    rateValue = String.valueOf(rateCell.getNumericCellValue());
} else {
    rateValue = ""; // Handle any other unexpected cell types as empty or according to your requirements
}
	
private static void writeResultsToExcel(List<String[]> outputResults, String outputPath) {
    try (Workbook workbook = new XSSFWorkbook()) {
        Sheet sheet = workbook.createSheet("Comparison Results");

        // Create header row
        Row headerRow = sheet.createRow(0);
        headerRow.createCell(0).setCellValue("Procedure Code + Modifier");
        headerRow.createCell(1).setCellValue("Rate");
        headerRow.createCell(2).setCellValue("Comparison Result");

        // Write each result as a new row
        int rowNum = 1;
        for (String[] result : outputResults) {
            Row row = sheet.createRow(rowNum++);
            row.createCell(0).setCellValue(result[0]);
            row.createCell(1).setCellValue(result[1]);
            row.createCell(2).setCellValue(result[2]);
        }

        // Save the workbook to the specified output path
        try (FileOutputStream fos = new FileOutputStream(outputPath)) {
            workbook.write(fos);
        }

        System.out.println("Results written to Excel file: " + outputPath);
    } catch (IOException e) {
        e.printStackTrace();
    }
}	
	
}

**********************

private static Map<String, List<Map<String, Object>>> loadExistingRatesFromDatabase() {
    Map<String, List<Map<String, Object>>> existingRates = new HashMap<>();
    try (Connection connection = DriverManager.getConnection(DB_URL, USER, PASSWORD);
         Statement statement = connection.createStatement()) {

        String query = "SELECT procedure_code, modifier, rate, eff_date, term_date FROM procedure_code_table";
        ResultSet rs = statement.executeQuery(query);

        while (rs.next()) {
            String procedureCode = rs.getString("procedure_code");
            String modifier = rs.getString("modifier");
            double rate = rs.getDouble("rate");
            Date effDate = rs.getDate("eff_date");
            Date termDate = rs.getDate("term_date");

            // Use procedureCode + modifier as the unique key
            String uniqueKey = procedureCode + modifier;

            // Create a map for this recordâ€™s details
            Map<String, Object> attributes = new HashMap<>();
            attributes.put("RATE", rate);
            attributes.put("EFF_DATE", effDate);
            attributes.put("TERM_DATE", termDate);

            // Add this record to the list associated with the uniqueKey
            existingRates.computeIfAbsent(uniqueKey, k -> new ArrayList<>()).add(attributes);
        }
    } catch (SQLException e) {
        e.printStackTrace();
    }
    return existingRates;
}


for (Map.Entry<String, Double> entry : revisedRates.entrySet()) {
    String uniqueKey = entry.getKey(); // This is procedureCode + modifier
    double sourceRate = entry.getValue(); // Rate from source file
    String assumedEffDate = "2024-01-01";
    String assumedTermDate = "2024-03-31";

    String result = "New Code"; // Default result if no conditions match

    if (existingRates.containsKey(uniqueKey)) {
        List<Map<String, Object>> dbRecords = existingRates.get(uniqueKey);
        
        for (Map<String, Object> dbRecord : dbRecords) {
            double dbRate = (double) dbRecord.get("RATE");
            Date dbEffDate = (Date) dbRecord.get("EFF_DATE");
            Date dbTermDate = (Date) dbRecord.get("TERM_DATE");

            // Step 1: Check if PROC + MOD + EFF + TERM + Rate match exactly
            if (dbEffDate.toString().equals(assumedEffDate) && dbTermDate.toString().equals(assumedTermDate) && dbRate == sourceRate) {
                result = "No change";
                break;
            }
            // Step 2: Check if PROC + MOD + TERM + Rate match (EFF differs)
            else if (dbTermDate.toString().equals(assumedTermDate) && dbRate == sourceRate) {
                result = "No change - Eff date differ";
                break;
            }
            // Step 3: Check if PROC + MOD + '12/31/9999' + Rate match
            else if (dbTermDate.toString().equals("9999-12-31") && dbRate == sourceRate) {
                result = "No change - Open End date";
                break;
            }
        }
        
        // If no exact match found but PROC + MOD exists, it indicates a rate change
        if ("New Code".equals(result)) {
            result = "Rate change";
        }
    }

    // Output or store result
    System.out.printf("Procedure Code + Modifier: %s, Rate: %.2f - %s%n", uniqueKey, sourceRate, result);
}


********************************************

import org.apache.pdfbox.pdmodel.PDDocument;
import org.apache.pdfbox.text.PDFTextStripper;
import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

public class PDFTableExtractor {
    public static void main(String[] args) throws IOException {
        File pdfFile = new File("path/to/your/pdf-file.pdf");
        File excelFile = new File("path/to/save/extracted-tables.xlsx");

        // Load PDF document
        try (PDDocument document = PDDocument.load(pdfFile)) {
            PDFTextStripper stripper = new PDFTextStripper();

            // Use a list to store rows of the table we extract
            List<List<String>> tableRows = new ArrayList<>();

            // Process each page
            for (int i = 1; i <= document.getNumberOfPages(); i++) {
                stripper.setStartPage(i);
                stripper.setEndPage(i);

                String pageText = stripper.getText(document);

                // Check if this page contains the specific headers
                if (pageText.contains("Code") && pageText.contains("Mod1") &&
                    pageText.contains("Mod2") && pageText.contains("Mod3") &&
                    pageText.contains("Mod4") && pageText.contains("Rates")) {

                    // Use a regular expression or manual parsing to extract table rows
                    List<String> rows = extractTableRows(pageText);
                    for (String row : rows) {
                        // Split by whitespace, tabs, or commas based on your table's format
                        String[] columns = row.split("\\s+");
                        tableRows.add(List.of(columns));
                    }
                }
            }

            // Write extracted table data to Excel
            writeDataToExcel(tableRows, excelFile);
        }
    }

    private static List<String> extractTableRows(String pageText) {
        // Add code here to identify the rows of the table based on specific patterns.
        // This can be a custom regular expression or any other logic to find rows.
        List<String> rows = new ArrayList<>();
        // Sample logic to get rows:
        String[] lines = pageText.split("\n");
        boolean inTable = false;
        for (String line : lines) {
            if (line.contains("Code") && line.contains("Rates")) {
                inTable = true; // Start of the table
            } else if (inTable && line.trim().isEmpty()) {
                break; // End of the table
            } else if (inTable) {
                rows.add(line);
            }
        }
        return rows;
    }

    private static void writeDataToExcel(List<List<String>> tableRows, File excelFile) throws IOException {
        Workbook workbook = new XSSFWorkbook();
        Sheet sheet = workbook.createSheet("Extracted Table");

        int rowNum = 0;
        for (List<String> rowData : tableRows) {
            Row row = sheet.createRow(rowNum++);
            int colNum = 0;
            for (String cellData : rowData) {
                Cell cell = row.createCell(colNum++);
                cell.setCellValue(cellData);
            }
        }

        try (FileOutputStream outputStream = new FileOutputStream(excelFile)) {
            workbook.write(outputStream);
        }
    }
}


<dependency>
    <groupId>org.apache.pdfbox</groupId>
    <artifactId>pdfbox</artifactId>
    <version>2.0.27</version>
</dependency>
<dependency>
    <groupId>org.apache.poi</groupId>
    <artifactId>poi</artifactId>
    <version>5.2.3</version>
</dependency>
<dependency>
    <groupId>org.apache.poi</groupId>
    <artifactId>poi-ooxml</artifactId>
    <version>5.2.3</version>
</dependency>




