import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;

import java.io.FileInputStream;
import java.io.IOException;
import java.sql.*;
import java.util.HashMap;
import java.util.Map;

public class RateComparison {

    // Database connection details
    private static final String DB_URL = "jdbc:sqlserver://localhost:1433;databaseName=YourDatabase";
    private static final String USER = "your_username";
    private static final String PASSWORD = "your_password";

    public static void main(String[] args) {
        String filePath = "path/to/your/revised_file.xlsx";
        Map<String, Double> revisedRates = loadRevisedRates(filePath);
        Map<String, Double> existingRates = loadExistingRatesFromDatabase();
        
        compareRates(revisedRates, existingRates);
    }

    // Step 1: Load revised rates from the Excel file
    private static Map<String, Double> loadRevisedRates(String filePath) {
        Map<String, Double> revisedRates = new HashMap<>();
        try (FileInputStream fis = new FileInputStream(filePath);
             Workbook workbook = new XSSFWorkbook(fis)) {
             
            Sheet sheet = workbook.getSheetAt(0); // Assuming data is in the first sheet
            for (Row row : sheet) {
                if (row.getRowNum() == 0) continue; // Skip header row
                
                Cell procedureCodeCell = row.getCell(0);
                Cell modifierCell = row.getCell(1);
                Cell rateCell = row.getCell(2);
                
                String procedureCode = procedureCodeCell.getStringCellValue();
                String modifier = modifierCell.getStringCellValue();
                String rateValue = rateCell.getStringCellValue().trim();
                
                // Concatenate ProcedureCode and Modifier to form a unique key
                String uniqueKey = procedureCode + modifier;
                
                // Scrub and handling conditions
                if ("NA".equalsIgnoreCase(rateValue) || "$0".equals(rateValue)) {
                    continue; // Ignore this PROC+MOD combination
                }
                
                double rate;
                if ("M".equalsIgnoreCase(rateValue)) {
                    rate = 0.0; // Manual rate set to 0
                } else {
                    rate = Double.parseDouble(rateValue);
                }
                
                revisedRates.put(uniqueKey, rate);
            }
        } catch (IOException | NumberFormatException e) {
            e.printStackTrace();
        }
        return revisedRates;
    }

    // Step 2: Load existing rates from the SQL Server database
private static Map<String, Map<String, Object>> loadExistingRatesFromDatabase() {
    Map<String, Map<String, Object>> existingRates = new HashMap<>();
    try (Connection connection = DriverManager.getConnection(DB_URL, USER, PASSWORD);
         Statement statement = connection.createStatement()) {
         
        String query = "SELECT procedure_code, modifier, rate, eff_date, term_date FROM procedure_code_table";
        ResultSet rs = statement.executeQuery(query);
        
        while (rs.next()) {
            String procedureCode = rs.getString("procedure_code");
            String modifier = rs.getString("modifier");
            double rate = rs.getDouble("rate");
            Date effDate = rs.getDate("eff_date");
            Date termDate = rs.getDate("term_date");
            
            String uniqueKey = procedureCode + modifier + rate;
            
            Map<String, Object> attributes = new HashMap<>();
            attributes.put("EFF_DATE", effDate);
            attributes.put("TERM_DATE", termDate);
            attributes.put("RATE", rate);
            
            existingRates.put(uniqueKey, attributes);
        }
    } catch (SQLException e) {
        e.printStackTrace();
    }
    return existingRates;
}

    // Step 3: Compare rates between revised source and existing database records
    private static void compareRates(Map<String, Double> revisedRates, Map<String, Double> existingRates) {
	List<String[]> outputResults = new ArrayList<>();
	
for (Map.Entry<String, Double> entry : revisedRates.entrySet()) {
    String uniqueKey = entry.getKey();
    double rate = entry.getValue();
    String assumedEffDate = "2024-01-01";
    String assumedTermDate = "2024-03-31";
    
    String result = "New Code"; // Default result if no conditions match
    
    if (existingRates.containsKey(uniqueKey)) {
        Map<String, Object> dbRecord = existingRates.get(uniqueKey);
        
        Date dbEffDate = (Date) dbRecord.get("EFF_DATE");
        Date dbTermDate = (Date) dbRecord.get("TERM_DATE");
        double dbRate = (double) dbRecord.get("RATE");
        
        if (dbEffDate.toString().equals(assumedEffDate) && dbTermDate.toString().equals(assumedTermDate) && dbRate == rate) {
            result = "No change";
        } else if (dbTermDate.toString().equals(assumedTermDate) && dbRate == rate) {
            result = "No change - Eff date differ";
        } else if (dbTermDate.toString().equals("9999-12-31") && dbRate == rate) {
            result = "No change - Open End date";
        } else if (existingRates.containsKey(procedureCode + modifier)) {
            result = "Rate change";
        }
    }
    
    // Add the result to outputResults for writing to Excel
    outputResults.add(new String[]{uniqueKey, String.valueOf(rate), result});
}

String outputPath = "path/to/output/comparison_results.xlsx";
writeResultsToExcel(outputResults, outputPath);
    }
	
	Cell rateCell = row.getCell(2); // Assuming the rate is in the third column
String rateValue;

if (rateCell.getCellType() == CellType.STRING) {
    rateValue = rateCell.getStringCellValue().trim();
} else if (rateCell.getCellType() == CellType.NUMERIC) {
    rateValue = String.valueOf(rateCell.getNumericCellValue());
} else {
    rateValue = ""; // Handle any other unexpected cell types as empty or according to your requirements
}
	
private static void writeResultsToExcel(List<String[]> outputResults, String outputPath) {
    try (Workbook workbook = new XSSFWorkbook()) {
        Sheet sheet = workbook.createSheet("Comparison Results");

        // Create header row
        Row headerRow = sheet.createRow(0);
        headerRow.createCell(0).setCellValue("Procedure Code + Modifier");
        headerRow.createCell(1).setCellValue("Rate");
        headerRow.createCell(2).setCellValue("Comparison Result");

        // Write each result as a new row
        int rowNum = 1;
        for (String[] result : outputResults) {
            Row row = sheet.createRow(rowNum++);
            row.createCell(0).setCellValue(result[0]);
            row.createCell(1).setCellValue(result[1]);
            row.createCell(2).setCellValue(result[2]);
        }

        // Save the workbook to the specified output path
        try (FileOutputStream fos = new FileOutputStream(outputPath)) {
            workbook.write(fos);
        }

        System.out.println("Results written to Excel file: " + outputPath);
    } catch (IOException e) {
        e.printStackTrace();
    }
}	
	
}

**********************

private static Map<String, List<Map<String, Object>>> loadExistingRatesFromDatabase() {
    Map<String, List<Map<String, Object>>> existingRates = new HashMap<>();
    try (Connection connection = DriverManager.getConnection(DB_URL, USER, PASSWORD);
         Statement statement = connection.createStatement()) {

        String query = "SELECT procedure_code, modifier, rate, eff_date, term_date FROM procedure_code_table";
        ResultSet rs = statement.executeQuery(query);

        while (rs.next()) {
            String procedureCode = rs.getString("procedure_code");
            String modifier = rs.getString("modifier");
            double rate = rs.getDouble("rate");
            Date effDate = rs.getDate("eff_date");
            Date termDate = rs.getDate("term_date");

            // Use procedureCode + modifier as the unique key
            String uniqueKey = procedureCode + modifier;

            // Create a map for this recordâ€™s details
            Map<String, Object> attributes = new HashMap<>();
            attributes.put("RATE", rate);
            attributes.put("EFF_DATE", effDate);
            attributes.put("TERM_DATE", termDate);

            // Add this record to the list associated with the uniqueKey
            existingRates.computeIfAbsent(uniqueKey, k -> new ArrayList<>()).add(attributes);
        }
    } catch (SQLException e) {
        e.printStackTrace();
    }
    return existingRates;
}


for (Map.Entry<String, Double> entry : revisedRates.entrySet()) {
    String uniqueKey = entry.getKey(); // This is procedureCode + modifier
    double sourceRate = entry.getValue(); // Rate from source file
    String assumedEffDate = "2024-01-01";
    String assumedTermDate = "2024-03-31";

    String result = "New Code"; // Default result if no conditions match

    if (existingRates.containsKey(uniqueKey)) {
        List<Map<String, Object>> dbRecords = existingRates.get(uniqueKey);
        
        for (Map<String, Object> dbRecord : dbRecords) {
            double dbRate = (double) dbRecord.get("RATE");
            Date dbEffDate = (Date) dbRecord.get("EFF_DATE");
            Date dbTermDate = (Date) dbRecord.get("TERM_DATE");

            // Step 1: Check if PROC + MOD + EFF + TERM + Rate match exactly
            if (dbEffDate.toString().equals(assumedEffDate) && dbTermDate.toString().equals(assumedTermDate) && dbRate == sourceRate) {
                result = "No change";
                break;
            }
            // Step 2: Check if PROC + MOD + TERM + Rate match (EFF differs)
            else if (dbTermDate.toString().equals(assumedTermDate) && dbRate == sourceRate) {
                result = "No change - Eff date differ";
                break;
            }
            // Step 3: Check if PROC + MOD + '12/31/9999' + Rate match
            else if (dbTermDate.toString().equals("9999-12-31") && dbRate == sourceRate) {
                result = "No change - Open End date";
                break;
            }
        }
        
        // If no exact match found but PROC + MOD exists, it indicates a rate change
        if ("New Code".equals(result)) {
            result = "Rate change";
        }
    }

    // Output or store result
    System.out.printf("Procedure Code + Modifier: %s, Rate: %.2f - %s%n", uniqueKey, sourceRate, result);
}



